package Demo01InnerClass;

/*
如果一个事物的内部包含有另外一个事物，那么这就是一个类内部包含另一个类。
例如：身体和心脏的关系。又如，汽车和发动机的关系。

内部类的分类：
1.成员内部类。
2.局部内部类（包含匿名内部类）。

A.定义内部类：
format：
1.成员内部类：内用外可以随意使用。 外用内需要借助内部类对象。
public class 外部类名称 {
    //...
    public class 内部类名称 {
        //...
    }
    //..
}

2.局部内部类：如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。 只有当前方法可以使用它，除了这个方法就不可以了。
修饰符 class 外部类名称 {
    修饰符 返回值类型 外部类方法名称(参数列表) {
        class 局部内部类名称{
            //...
        }
    }
}

3.匿名内部类：如果接口的实现类(或者是父类的子类)只需要使用唯一的一次，
那么这种情况下就可以不用一个专门的实现类来实现接口(或者继承父类)，而改为使用【匿名内部类】。
format：
接口名称 对象名 = new 接口名称() {
    //覆盖重写接口中的所有抽象方法
}

【对匿名内部类的format进行解析】：
1.new代表创建对象的动作
2.接口名称就是匿名内部类需要实现那个接口。
3.{...}这才是匿名内部类的内容。

另外还需注意几点关于匿名内部类：
1.匿名内部类在【创将对象】的时候只能使用惟一一次，如果希望多次创建对象，而且类的内容一样的话，那就必须单独定义实现类。
2.匿名对象，在【调用方法】的时候，只能调用依次。
如果希望一个对象调用多次方法，那必须给对象起个名字。
3.匿名内部类省略了【实现类/子类名称】，但是匿名对象省略了【对象名称】。
强调：匿名内部类和匿名对象不是一回事。


B.使用内部类：
1.成员内部类:
间接方式：在外部类的方法当中，使用内部类，然后main只是调用外部类的方法。
直接方式：format：【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();】


内部类的同名变量访问：
如果出现了重名现象，那么访问外部类中成员变量的方法是
format：外部类名称.this.外部类成员变量

小结一下类的权限修饰符：
public > protected > (default) > private
定义一个类的时候，权限修饰符规则：
1.外部类:public / (default)
2.成员内部类:public/protected/(default)/private
3.局部内部类：什么都不能些

局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。

备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。

原因：
1.new出来的对象在堆内存中。
2.局部变量是跟着方法走的，在栈内存当中。
3.方法运行结束后，立刻出栈，局部变量就会立刻消失。
4.但是new出来的对象会在堆当中持续存在，直到垃圾回收为止。
5.因此可能会存在某方法结束，但是对象依然想要访问局部变量的情况。
此时就需要那个局部变量是final的，此时在内部类中访问该常量，就只需要自己保存一份，常量本身被删除不影响内部类对他的使用。

 */

public class InnerClass {

    public static void main(String[] args) {

        MyInterface obj = new MyInterface() {
            @Override
            public void method() {
                System.out.println("匿名内部类实现了方法");
            }
        };
        obj.method();
    }

}
